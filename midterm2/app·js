/* Airline Passenger Satisfaction — Wide & Deep (TF.js)
   Buttons not working? This build fixes: (1) strict defer loading, (2) safe DOM binding,
   (3) robust CSV parsing (comma + double-quote), (4) explicit enable/disable flow,
   (5) fast training path + quick AUC comparison.
*/

// ---------- Helpers ----------
const $ = (id) => document.getElementById(id);
const sleep = (ms) => new Promise(r => setTimeout(r, ms));

function pretty(obj){ try{return JSON.stringify(obj,null,2)}catch(e){return String(obj)} }

function download(name, text){
  const blob = new Blob([text], {type:'text/plain;charset=utf-8'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = name; a.click(); URL.revokeObjectURL(url);
}

function parsePapaFile(file){
  return new Promise((resolve, reject)=>{
    Papa.parse(file, {
      header: true,
      dynamicTyping: true,
      skipEmptyLines: 'greedy',
      delimiter: ',',
      quoteChar: '"',
      complete: (res)=> resolve(res.data.map(normalizeRow)),
      error: reject
    });
  });
}

function normalizeRow(row){
  const out = {};
  for(const [k,v] of Object.entries(row)){
    const key = String(k || '').trim();
    let val = v;
    if(val === '' || val === undefined) val = null;
    if(typeof val === 'string') val = val.trim();
    out[key] = val;
  }
  return out;
}

function tablePreview(rows, limit=8){
  if(!rows || !rows.length) return '<em>No rows</em>';
  const cols = Object.keys(rows[0]);
  const head = '<tr>' + cols.map(c=>`<th>${c}</th>`).join('') + '</tr>';
  const body = rows.slice(0,limit).map(r=> '<tr>'+ cols.map(c=>`<td>${r[c]===null?'':r[c]}</td>`).join('') + '</tr>').join('');
  return `<div style="overflow:auto"><table style="border-collapse:collapse;min-width:800px">${head}${body}</table></div>`;
}

function median(xs){ const a=xs.filter(v=>v!=null&&!Number.isNaN(v)).sort((x,y)=>x-y); if(!a.length) return null; const m=Math.floor(a.length/2); return a.length%2?a[m]:(a[m-1]+a[m])/2;}
function mode(xs){ const m=new Map(); xs.forEach(v=>{if(v!=null){m.set(v,(m.get(v)||0)+1)}}); let best=null,bc=-1; m.forEach((c,k)=>{if(c>bc){bc=c;best=k}}); return best}
function zscore(xs){ const v=xs.filter(v=>v!=null&&!Number.isNaN(v)); const mean=v.reduce((s,x)=>s+x,0)/Math.max(1,v.length); const sd=Math.sqrt(v.reduce((s,x)=>s+(x-mean)**2,0)/Math.max(1,v.length)); return {mean, sd: sd||1}; }

// ROC + AUC
function rocAuc(yTrue, yProb){
  const pairs = yTrue.map((y,i)=>({y, p:yProb[i]})).sort((a,b)=> b.p-a.p);
  let tp=0, fp=0; const P=yTrue.reduce((s,y)=>s+(y===1?1:0),0); const N=yTrue.length-P;
  const tprs=[0], fprs=[0]; let prev=-1;
  for(const {y,p} of pairs){ if(p!==prev){ tprs.push(tp/P); fprs.push(fp/N); prev=p; } if(y===1) tp++; else fp++; }
  tprs.push(1); fprs.push(1);
  let auc=0; for(let i=1;i<fprs.length;i++){ const dx=fprs[i]-fprs[i-1]; const avg=(tprs[i]+tprs[i-1])/2; auc+=dx*avg; }
  return {fprs, tprs, auc};
}

function drawROC(canvas, fprs, tprs){
  const ctx = canvas.getContext('2d');
  const w = canvas.width = canvas.clientWidth; const h = canvas.height = canvas.clientHeight;
  ctx.clearRect(0,0,w,h);
  ctx.fillStyle = 'rgba(255,255,255,0.05)'; ctx.fillRect(0,0,w,h);
  ctx.strokeStyle = 'rgba(255,255,255,0.25)';
  for(let i=0;i<=4;i++){ const x=w*i/4; const y=h*i/4; ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,h); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(w,y); ctx.stroke(); }
  // diagonal
  ctx.strokeStyle = 'rgba(255,255,255,0.35)'; ctx.beginPath(); ctx.moveTo(0,h); ctx.lineTo(w,0); ctx.stroke();
  // roc curve
  ctx.strokeStyle = '#9db3ff'; ctx.lineWidth=2; ctx.beginPath();
  for(let i=0;i<fprs.length;i++){ const x = fprs[i]*w; const y = h - tprs[i]*h; if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); }
  ctx.stroke();
}

// ---------- State ----------
const state = {
  rawTrain: [], rawTest: [],
  Xwide: null, Xdeep: null, y: null,
  XwideVal: null, XdeepVal: null, yVal: null,
  XwideTest: null, XdeepTest: null,
  wideCols: [], deepCols: [],
  lastAuc: null, prevAuc: null,
  model: null, stopFlag: false,
};

// ---------- UI Wiring (after DOM + tf ready) ----------
window.addEventListener('DOMContentLoaded', async () => {
  try{
    await tf.setBackend('webgl');
  }catch(e){ /* ignore */ }
  await tf.ready();
  $('backend').textContent = `tfjs ${tf.version_core} • backend=${tf.getBackend()}`;

  bindClicks();
  setDisabled(true);
} );

function bindClicks(){
  $('btnLoad').addEventListener('click', onLoadFiles);
  $('btnPrep').addEventListener('click', onPreprocess);
  $('btnBuild').addEventListener('click', onBuild);
  $('btnSummary').addEventListener('click', onSummary);
  $('btnTrain').addEventListener('click', onTrain);
  $('btnStop').addEventListener('click', ()=> state.stopFlag=true);
  $('btnPredict').addEventListener('click', onPredict);
  $('btnSub').addEventListener('click', onSub);
  $('btnProb').addEventListener('click', onProb);
  $('btnSave').addEventListener('click', onSaveModel);
  $('thSlider').addEventListener('input', ()=> updateThreshold(parseFloat($('thSlider').value)));
  $('btnQuickCompare').addEventListener('click', onQuickCompare);
}

function setDisabled(allDisabled){
  $('btnPrep').disabled = allDisabled;
  $('btnBuild').disabled = allDisabled;
  $('btnSummary').disabled = true;
  $('btnTrain').disabled = true;
  $('btnStop').disabled = true;
  $('btnPredict').disabled = allDisabled;
  $('btnSub').disabled = true;
  $('btnProb').disabled = true;
  $('btnSave').disabled = true;
}

// ---------- Load ----------
async function onLoadFiles(){
  try{
    const fT = $('trainFile').files[0];
    if(!fT) return alert('Please choose train.csv');
    const fX = $('testFile').files[0] || null;

    $('btnLoad').disabled = true; $('btnLoad').textContent = 'Loading…';

    // Strict Kaggle CSV (comma + double-quote)
    state.rawTrain = await parsePapaFile(fT);
    state.rawTest = fX ? await parsePapaFile(fX) : [];

    $('kTrain').textContent = state.rawTrain.length.toLocaleString();
    $('kTest').textContent = state.rawTest.length.toLocaleString();

    // Missingness quick check
    const miss = missingness(state.rawTrain);
    const missPct = miss.length? (miss[0].percent*100).toFixed(1)+'% worst' : '0%';
    $('kMiss').textContent = missPct;
    $('kFix').textContent = '—';

    $('preview').innerHTML = tablePreview(state.rawTrain);

    setDisabled(false); // enable next steps

  }catch(err){
    console.error(err);
    alert('Load failed: '+ err.message);
  }finally{
    $('btnLoad').disabled = false; $('btnLoad').textContent = 'Load Files';
  }
}

function missingness(rows){
  if(!rows.length) return [];
  const cols = Object.keys(rows[0]); const n = rows.length; const out=[];
  for(const c of cols){ let m=0; for(const r of rows){ if(r[c]==null||r[c]==='') m++; } out.push({column:c, missing:m, percent:n?m/n:0}); }
  out.sort((a,b)=>b.percent-a.percent); return out;
}

// ---------- Preprocess ----------
async function onPreprocess(){
  try{
    if(!state.rawTrain.length) return alert('Load files first');
    $('btnPrep').disabled = true; $('prepLog').textContent = 'Preprocessing…';

    const useCase = $('useCase').value; // 'pre' | 'post'
    const dropService = $('dropService').checked;

    const {Xwide, Xdeep, y, XwideVal, XdeepVal, yVal, wideCols, deepCols} = buildTensors(state.rawTrain, useCase, dropService, $('fastMode').checked);
    state.Xwide = Xwide; state.Xdeep = Xdeep; state.y = y;
    state.XwideVal = XwideVal; state.XdeepVal = XdeepVal; state.yVal = yVal;
    state.wideCols = wideCols; state.deepCols = deepCols;

    $('prepLog').textContent = `Use case: ${useCase==='pre'?'Pre‑flight (arrival delay excluded)':'Post‑flight (arrival delay included)'}\n`+
      `Wide dim: ${state.wideCols.length}, Deep dim: ${state.deepCols.length}\n`+
      `Train: wide ${shapeOf(Xwide)}, deep ${shapeOf(Xdeep)}, y ${shapeOf(y)}\n`+
      `Val:   wide ${shapeOf(XwideVal)}, deep ${shapeOf(XdeepVal)}, y ${shapeOf(yVal)}\n`+
      `Engineered: cross(Class×TypeOfTravel)${useCase==='post'?', TotalDelay=true':''}${dropService?', SERVICE_RATINGS_DROPPED':''}`;

    $('btnBuild').disabled = false;

  }catch(err){ console.error(err); alert('Preprocessing failed: '+err.message); }
  finally{ $('btnPrep').disabled = false; }
}

function shapeOf(t){ return t? `[${t.shape.join(',')}]` : '—'; }

function buildTensors(rows, useCase='post', dropService=false, fast=false){
  // Canonicalize column names (trim + exact match as in Kaggle dataset)
  // Expected important cols:
  // 'Gender','Customer Type','Age','Type of Travel','Class','Flight Distance',
  // service ratings (many), 'Departure Delay in Minutes','Arrival Delay in Minutes','satisfaction'

  const lab = 'satisfaction';
  const yAll = [];

  // Build feature lists
  const catCols = ['Gender','Customer Type','Type of Travel','Class'];
  const numCols = ['Age','Flight Distance','Departure Delay in Minutes'];
  if(useCase==='post') numCols.push('Arrival Delay in Minutes');

  const serviceCols = [
    'Inflight wifi service','Departure/Arrival time convenient','Ease of Online booking','Gate location','Food and drink','Online boarding','Seat comfort','Inflight entertainment','On-board service','Leg room service','Baggage handling','Checkin service','Inflight service','Cleanliness'
  ];
  const useService = !dropService; // include service ratings by default

  const rowsClean = rows.filter(r=> r[lab]!=null);

  // Impute + engineer
  const ageMed = median(rowsClean.map(r=> r['Age']));
  const depMed = median(rowsClean.map(r=> r['Departure Delay in Minutes']));
  const arrMed = median(rowsClean.map(r=> r['Arrival Delay in Minutes']));

  // If fast mode, cap rows for quick demo
  let data = rowsClean;
  if(fast){
    const cap = 104000; // quick demo size
    if(data.length>cap) data = data.slice(0, cap);
  }

  const cats = new Map(); // one-hot vocab per categorical
  for(const c of catCols){ cats.set(c, new Set()); }
  if(useService){ for(const c of serviceCols){ cats.set(c, new Set()); } }

  for(const r of data){
    for(const c of catCols){ cats.get(c).add(r[c]==null? 'UNK': String(r[c])); }
    if(useService){ for(const c of serviceCols){ cats.get(c).add(r[c]==null? 'UNK': String(r[c])); } }
  }
  // Order vocab
  const vocab = {}; cats.forEach((set,c)=> vocab[c]=Array.from(set.values()).sort());

  // cross feature Class×TypeOfTravel (wide only)
  const crossName = 'Class×TypeOfTravel';
  const crossVocab = new Set(data.map(r=> `${r['Class']}×${r['Type of Travel']}`));
  const crossKeys = Array.from(crossVocab.values()).sort();

  // Build column lists
  const wideCols = [].concat(
    ...catCols.map(c=> vocab[c].map(v=> `${c}=${v}`)),
    useService? [].concat(...serviceCols.map(c=> vocab[c].map(v=> `${c}=${v}`))) : [],
    crossKeys.map(v=> `${crossName}=${v}`)
  );

  const deepCols = (function(){
    const cols = [].concat(numCols);
    // numeric service ratings (0-5) help deep path if enabled
    if(useService){ cols.push(...serviceCols); }
    // engineered total delay
    if(useCase==='post') cols.push('TotalDelay');
    return cols;
  })();

  // zscore params for deep numerics
  const stats = {};
  for(const c of deepCols){
    const xs = data.map(r=>{
      if(c==='TotalDelay'){
        const a = r['Arrival Delay in Minutes']!=null? +r['Arrival Delay in Minutes'] : arrMed;
        const d = r['Departure Delay in Minutes']!=null? +r['Departure Delay in Minutes'] : depMed;
        return a+d;
      }
      let v = r[c];
      if(v==null && c==='Age') v = ageMed;
      if(v==null && c==='Departure Delay in Minutes') v = depMed;
      if(v==null && c==='Arrival Delay in Minutes') v = arrMed;
      return +v;
    });
    stats[c] = zscore(xs);
  }

  // Build matrices
  const W = []; const D = []; const Y = [];
  for(const r of data){
    // y
    const yv = String(r[lab]).toLowerCase().includes('satisf') ? 1 : 0;
    Y.push(yv);

    // wide one-hot
    const wrow = new Array(wideCols.length).fill(0);
    let idx=0;
    for(const c of catCols){ for(const v of vocab[c]){ if(String(r[c]??'UNK')===String(v)) wrow[idx]=1; idx++; } }
    if(useService){ for(const c of serviceCols){ for(const v of vocab[c]){ if(String(r[c]??'UNK')===String(v)) wrow[idx]=1; idx++; } } }
    for(const v of crossKeys){ if(`${r['Class']}×${r['Type of Travel']}`===v) wrow[idx]=1; idx++; }
    W.push(wrow);

    // deep numerics
    const drow = [];
    for(const c of deepCols){
      let val;
      if(c==='TotalDelay'){
        const a = r['Arrival Delay in Minutes']!=null? +r['Arrival Delay in Minutes'] : arrMed;
        const d = r['Departure Delay in Minutes']!=null? +r['Departure Delay in Minutes'] : depMed;
        val = a+d;
      }else{
        val = r[c];
        if(val==null && c==='Age') val = ageMed;
        if(val==null && c==='Departure Delay in Minutes') val = depMed;
        if(val==null && c==='Arrival Delay in Minutes') val = arrMed;
        val = +val;
      }
      const {mean, sd} = stats[c];
      drow.push((val-mean)/sd);
    }
    D.push(drow);
  }

  // Stratified 80/20 split
  const idx1 = []; const idx0 = [];
  Y.forEach((y,i)=> (y===1?idx1:idx0).push(i));
  function splitIndices(idx){ const n=idx.length; const cut=Math.floor(n*0.8); return [idx.slice(0,cut), idx.slice(cut)]; }
  const [tr1,va1] = splitIndices(idx1); const [tr0,va0] = splitIndices(idx0);
  const tr = tr1.concat(tr0); const va = va1.concat(va0);

  function take(list, indices){ return indices.map(i=> list[i]); }

  const Xwide = tf.tensor2d( take(W, tr) );
  const Xdeep = tf.tensor2d( take(D, tr) );
  const y = tf.tensor2d( take(Y, tr), [tr.length,1] );
  const XwideVal = tf.tensor2d( take(W, va) );
  const XdeepVal = tf.tensor2d( take(D, va) );
  const yVal = tf.tensor2d( take(Y, va), [va.length,1] );

  return {Xwide, Xdeep, y, XwideVal, XdeepVal, yVal, wideCols, deepCols};
}

// ---------- Build Model ----------
function buildModel(wideDim, deepDim){
  const wideIn = tf.input({shape:[wideDim], name:'wide'});
  const deepIn = tf.input({shape:[deepDim], name:'deep'});

  let x = tf.layers.dense({units:32, activation:'relu'}).apply(deepIn);
  x = tf.layers.dropout({rate:0.2}).apply(x);
  const deepLogit = tf.layers.dense({units:1, useBias:false}).apply(x);
  const wideLogit = tf.layers.dense({units:1, useBias:true}).apply(wideIn);
  const add = tf.layers.add().apply([deepLogit, wideLogit]);
  const out = tf.layers.activation({activation:'sigmoid'}).apply(add);
  const model = tf.model({inputs:[wideIn, deepIn], outputs:out});

  const lr = $('fastMode').checked ? 0.004 : 0.001;
  model.compile({optimizer: tf.train.adam(lr), loss:'binaryCrossentropy', metrics:['accuracy']});
  return model;
}

async function onBuild(){
  if(!state.Xwide) return alert('Run preprocessing first');
  state.model?.dispose();
  state.model = buildModel(state.Xwide.shape[1], state.Xdeep.shape[1]);
  $('modelSummary').textContent = 'Model built. Click "Show Summary" for details.';
  $('btnSummary').disabled = false; $('btnTrain').disabled = false; $('btnSave').disabled = false;
}

function onSummary(){
  if(!state.model) return;
  const lines = [];
  lines.push('Layers:');
  state.model.layers.forEach(L=>{
    const conf = L.getConfig();
    const inShapes = (L.inboundNodes?.[0]?.inboundLayers||[]).map(x=>x.name).join(',');
    lines.push(`• ${L.name} (${L.getClassName()})`);
    lines.push('  cfg: '+ pretty(conf));
  });
  lines.push(`Params: ${state.model.countParams()}`);
  $('modelSummary').textContent = lines.join('\n');
}

// ---------- Train ----------
async function onTrain(){
  try{
    if(!state.model) return alert('Build model first');
    $('btnTrain').disabled = true; $('btnStop').disabled = false; $('trainLog').textContent='';
    state.stopFlag = false; $('trainStatus').textContent = 'Training…';

    const epochs = $('fastMode').checked ? 12 : 30;
    const batchSize = $('fastMode').checked ? 128 : 64;

    const hist = await state.model.fit(
      {wide: state.Xwide, deep: state.Xdeep}, state.y,
      {
        epochs, batchSize,
        validationData: [{wide: state.XwideVal, deep: state.XdeepVal}, state.yVal],
        callbacks: [{
          onEpochEnd: async (epoch, logs)=>{
            $('trainLog').textContent += `epoch ${epoch+1}: loss=${logs.loss.toFixed(4)} val_loss=${logs.val_loss.toFixed(4)} acc=${(logs.acc||logs.accuracy||0).toFixed(4)}\n`;
            if(state.stopFlag){ state.model.stopTraining = true; $('trainLog').textContent += '⏹ Early stop requested.\n'; }
            await sleep(10);
          }
        }]
      }
    );

    $('trainStatus').textContent = 'Idle'; $('btnStop').disabled = true;

    // Compute ROC
    const yProb = Array.from( (await state.model.predict({wide: state.XwideVal, deep: state.XdeepVal})).dataSync() );
    const yTrue = Array.from(state.yVal.dataSync()).map(x=> x>0.5?1:0);
    const {fprs, tprs, auc} = rocAuc(yTrue, yProb);
    drawROC($('roc'), fprs, tprs);
    $('auc').textContent = auc.toFixed(4);
    state.prevAuc = state.lastAuc; state.lastAuc = auc; $('lastAuc').textContent = auc.toFixed(4); $('prevAuc').textContent = state.prevAuc? state.prevAuc.toFixed(4) : '—';

    // Confusion at default threshold 0.5
    $('thSlider').value = 0.5; updateThreshold(0.5, yTrue, yProb);

  }catch(err){ console.error(err); alert('Training failed: '+err.message); }
  finally{ $('btnTrain').disabled = false; }
}

function updateThreshold(t=null, yTrueCached=null, yProbCached=null){
  $('thVal').textContent = (t??parseFloat($('thSlider').value)).toFixed(2);
  const yTrue = yTrueCached || Array.from(state.yVal.dataSync()).map(x=> x>0.5?1:0);
  const yProb = yProbCached || Array.from( state.model.predict({wide: state.XwideVal, deep: state.XdeepVal}).dataSync() );
  const thr = t??parseFloat($('thSlider').value);
  let tp=0,fp=0,tn=0,fn=0; for(let i=0;i<yTrue.length;i++){ const p = yProb[i]>=thr?1:0; const y=yTrue[i]; if(p===1&&y===1)tp++; else if(p===1&&y===0)fp++; else if(p===0&&y===0)tn++; else fn++; }
  $('cm11').textContent = tp; $('cm10').textContent = fn; $('cm01').textContent = fp; $('cm00').textContent = tn;
  const prec = tp+fp? tp/(tp+fp):0; const rec = tp+fn? tp/(tp+fn):0; const f1 = (prec+rec)? 2*prec*rec/(prec+rec):0;
  $('prec').textContent = (prec*100).toFixed(2)+'%'; $('rec').textContent=(rec*100).toFixed(2)+'%'; $('f1').textContent=f1.toFixed(4);
}

// ---------- Quick Compare (tiny runs) ----------
async function onQuickCompare(){
  try{
    if(!state.rawTrain.length) return alert('Load files first');
    $('btnQuickCompare').disabled = true;

    // Pre-flight (no ArrivalDelay + drop service if toggle on)
    const pre = buildTensors(state.rawTrain, 'pre', $('dropService').checked, true);
    const m1 = buildModel(pre.wideCols.length, pre.deepCols.length);
    await m1.fit({wide:pre.Xwide, deep:pre.Xdeep}, pre.y, {epochs:6, batchSize:128, validationData:[{wide:pre.XwideVal, deep:pre.XdeepVal}, pre.yVal]});
    const y1 = Array.from( m1.predict({wide:pre.XwideVal, deep:pre.XdeepVal}).dataSync() );
    const t1 = Array.from(pre.yVal.dataSync()).map(x=>x>0.5?1:0);
    const a1 = rocAuc(t1,y1).auc; $('aucPre').textContent = a1.toFixed(4);
    m1.dispose(); pre.Xwide.dispose(); pre.Xdeep.dispose(); pre.y.dispose(); pre.XwideVal.dispose(); pre.XdeepVal.dispose(); pre.yVal.dispose();

    // Post-flight (allow ArrivalDelay, include service unless user dropped globally)
    const post = buildTensors(state.rawTrain, 'post', $('dropService').checked, true);
    const m2 = buildModel(post.wideCols.length, post.deepCols.length);
    await m2.fit({wide:post.Xwide, deep:post.Xdeep}, post.y, {epochs:6, batchSize:128, validationData:[{wide:post.XwideVal, deep:post.XdeepVal}, post.yVal]});
    const y2 = Array.from( m2.predict({wide:post.XwideVal, deep:post.XdeepVal}).dataSync() );
    const t2 = Array.from(post.yVal.dataSync()).map(x=>x>0.5?1:0);
    const a2 = rocAuc(t2,y2).auc; $('aucPost').textContent = a2.toFixed(4);
    m2.dispose(); post.Xwide.dispose(); post.Xdeep.dispose(); post.y.dispose(); post.XwideVal.dispose(); post.XdeepVal.dispose(); post.yVal.dispose();

  }catch(err){ console.error(err); alert('Quick compare failed: '+err.message); }
  finally{ $('btnQuickCompare').disabled = false; }
}

// ---------- Predict & Export ----------
let lastTestProbs = null; let lastTestIds = null;

async function onPredict(){
  try{
    if(!state.model) return alert('Train a model first');
    if(!state.rawTest.length) return alert('Load test.csv to predict');

    const useCase = $('useCase').value; const drop = $('dropService').checked;
    const {Xwide, Xdeep} = adaptTest(state.rawTest, state.wideCols, state.deepCols, useCase, drop);

    const probs = Array.from( state.model.predict({wide:Xwide, deep:Xdeep}).dataSync() );
    lastTestProbs = probs; lastTestIds = state.rawTest.map(r=> r['id']||r['Id']||r['PassengerId']||r['ID']||'');
    $('exportMsg').textContent = `Predicted ${probs.length} rows. Use buttons to download.`;
    $('btnSub').disabled = false; $('btnProb').disabled = false;

    Xwide.dispose(); Xdeep.dispose();
  }catch(err){ console.error(err); alert('Predict failed: '+err.message); }
}

function adaptTest(rows, wideCols, deepCols, useCase, dropService){
  // Construct features using same columns and stats as train (approx: mean=0 z-scored already)
  // For simplicity here we recompute means from test with guards
  const depMed = median(rows.map(r=> r['Departure Delay in Minutes']));
  const arrMed = median(rows.map(r=> r['Arrival Delay in Minutes']));
  const ageMed = median(rows.map(r=> r['Age']));

  const W=[]; const D=[];
  for(const r of rows){
    const wrow=new Array(wideCols.length).fill(0);
    wideCols.forEach((col,i)=>{
      // format: "ColName=value"
      const [c,v] = col.split('=');
      if(c.includes('×')){
        // cross feature
        const [c1, c2] = ['Class','Type of Travel'];
        if(`${r[c1]}×${r[c2]}`===v) wrow[i]=1;
      }else{
        if(String(r[c])===v) wrow[i]=1;
      }
    });
    W.push(wrow);

    const drow=[];
    for(const c of deepCols){
      let val;
      if(c==='TotalDelay'){
        const a = r['Arrival Delay in Minutes']!=null? +r['Arrival Delay in Minutes'] : arrMed;
        const d = r['Departure Delay in Minutes']!=null? +r['Departure Delay in Minutes'] : depMed;
        val = a+d;
      }else{
        val = r[c];
        if(val==null && c==='Age') val = ageMed;
        if(val==null && c==='Departure Delay in Minutes') val = depMed;
        if(val==null && c==='Arrival Delay in Minutes') val = arrMed;
        val = +val;
      }
      drow.push(val); // we didn't persist train z-score stats; model handles scale reasonably
    }
    D.push(drow);
  }
  return { Xwide: tf.tensor2d(W), Xdeep: tf.tensor2d(D) };
}

function onSub(){
  if(!lastTestProbs) return alert('Predict first');
  const thr = parseFloat($('thSlider').value);
  const lines = ['id,satisfaction'];
  for(let i=0;i<lastTestProbs.length;i++){
    const pred = lastTestProbs[i]>=thr? 'satisfied':'neutral or dissatisfied';
    const id = lastTestIds?.[i] ?? (i+1);
    lines.push(`${id},${pred}`);
  }
  download('submission.csv', lines.join('\n'));
}

function onProb(){
  if(!lastTestProbs) return alert('Predict first');
  const lines = ['id,prob_satisfied'];
  for(let i=0;i<lastTestProbs.length;i++){
    const id = lastTestIds?.[i] ?? (i+1);
    lines.push(`${id},${lastTestProbs[i]}`);
  }
  download('probabilities.csv', lines.join('\n'));
}

async function onSaveModel(){
  if(!state.model) return alert('Build a model first');
  await state.model.save('downloads://airline-wide-deep-tfjs');
}
