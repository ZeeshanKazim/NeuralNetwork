/*
  Airline Passenger Satisfaction — Wide & Deep in TF.js
  - Very fast training path (subset, bigger batch, fewer epochs, mixed precision)
  - Toggle to drop all service rating columns (pre‑flight‑only)
  - One‑click quick comparison (pre vs post) shows AUCs side‑by‑side
  - Robust CSV parsing for Kaggle defaults (comma + double‑quote)
*/

// ---------- Globals ----------
const state = {
  rawTrain: [], rawTest: [],
  schema: null,
  prepped: null,
  model: null,
  training: false,
  lastAUC: null, // previous run's AUC
  roc: null, // {fpr:[], tpr:[], auc:number}
  valProbs: null, valY: null,
  fast: true,
};

// TF backend & speed knobs
(async () => {
  try {
    await tf.setBackend('webgl');
    // Lighter textures = faster on many GPUs
    if (tf.env().get('WEBGL_VERSION') > 0) {
      tf.env().set('WEBGL_PACK', true);
      // Force 16‑bit where possible
      tf.env().set('WEBGL_FORCE_F16_TEXTURES', true);
    }
  } catch {}
  document.getElementById('backendPill').textContent = `backend: ${tf.getBackend()}`;
})();

// ---------- DOM refs ----------
const el = (id)=>document.getElementById(id);
const d = {
  trainFile: el('trainFile'), testFile: el('testFile'), btnLoad: el('btnLoad'),
  loadStatus: el('loadStatus'), kTrain: el('kTrain'), kTest: el('kTest'), kMiss: el('kMiss'), kRep: el('kRep'), preview: el('preview'),
  useCase: el('useCase'), featCross: el('featCross'), featTotalDelay: el('featTotalDelay'), dropRatings: el('dropRatings'), fastMode: el('fastMode'), btnPrep: el('btnPrep'), prepInfo: el('prepInfo'),
  btnBuild: el('btnBuild'), btnSummary: el('btnSummary'), modelSummary: el('modelSummary'),
  btnTrain: el('btnTrain'), btnEarly: el('btnEarly'), trainStatus: el('trainStatus'), log: el('log'), btnCompare: el('btnCompare'),
  thr: el('thr'), aucNow: el('aucNow'), aucPrev: el('aucPrev'), aucPre: el('aucPre'), aucPost: el('aucPost'), roc: el('roc'),
  tp: el('tp'), fp: el('fp'), tn: el('tn'), fn: el('fn'), prec: el('prec'), rec: el('rec'), f1: el('f1'),
  btnPredict: el('btnPredict'), btnSub: el('btnSub'), btnProb: el('btnProb'), btnSave: el('btnSave'), predInfo: el('predInfo')
};

// ---------- Utilities ----------
const sleep = (ms)=> new Promise(r=>setTimeout(r,ms));
const pct = (x)=> Math.round(x*1000)/10;
const clamp = (x,a,b)=>Math.max(a,Math.min(b,x));
const sum = (a)=> a.reduce((s,v)=>s+v,0);
const mean = (a)=> a.length? sum(a)/a.length : 0;
const median = (a)=>{ const b=a.filter(v=>v!=null&&!Number.isNaN(v)).sort((x,y)=>x-y); if(!b.length) return null; const m=Math.floor(b.length/2); return b.length%2? b[m] : (b[m-1]+b[m])/2; };
function downloadCsv(name, rows){ if(!rows.length) return; const cols=Object.keys(rows[0]); const esc=v=>{ if(v==null) return ''; const s=String(v); return /[",\n]/.test(s)? '"'+s.replace(/"/g,'""')+'"' : s; }; const csv=[cols.join(',')].concat(rows.map(r=>cols.map(c=>esc(r[c])).join(','))).join('\n'); const blob=new Blob([csv],{type:'text/csv;charset=utf-8;'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download=name; a.click(); URL.revokeObjectURL(url); }

// Robust header canonicalizer (lowercase, strip non‑alnum)
const canon = (s)=> String(s||'').toLowerCase().replace(/[^a-z0-9]+/g,'').trim();

// Kaggle‑style CSV parser (comma + double‑quote)
function parseWithPapa(file){
  return new Promise((resolve,reject)=>{
    Papa.parse(file, { header:true, skipEmptyLines:'greedy', dynamicTyping:true, quoteChar:'"', delimiter:',', complete:r=>resolve(r.data), error:reject });
  });
}

function normalizeRow(row){
  const out={};
  for(const [k,v] of Object.entries(row)){
    const key = canon(k);
    let val = (v===''||v===undefined)? null : v;
    // Map satisfaction words to 0/1
    if(key==='satisfaction'){
      const s = String(val).toLowerCase();
      out[key] = (s.includes('satisfied') && !s.includes('neutral')) ? 1 : 0; // "neutral or dissatisfied" -> 0
      continue;
    }
    out[key]=val;
  }
  return out;
}

// feature sets
const SERVICE_KEYS = new Set([
  'inflightwifiservice','departurearrivaltimeconvenient','easeofonlinebooking','gatelocation','foodanddrink','onlineboarding','seatcomfort','inflightentertainment','onboardservice','legroomservice','baggagehandling','checkinservice','cleanliness'
]);

// Some datasets include delay cols with spacing variants
const DELAY_KEYS = {
  dep: new Set(['departuredelayinminutes','departuredelay','departuredelaymin','departuredelaymins']),
  arr: new Set(['arrivaldelayinminutes','arrivaldelay','arrivaldelaymin','arrivaldelaymins'])
};

// Show preview table (first 5 rows)
function renderPreview(rows){
  if(!rows.length){ d.preview.innerHTML=''; return; }
  const cols = Object.keys(rows[0]);
  const head = '<tr>'+cols.map(c=>`<th>${c}</th>`).join('')+'</tr>';
  const body = rows.slice(0,8).map(r=>'<tr>'+cols.map(c=>`<td>${r[c]??''}</td>`).join('')+'</tr>').join('');
  d.preview.innerHTML = `<div style="overflow:auto"><table>${head}${body}</table></div>`;
}

// ---------- Load CSVs ----------
async function loadFiles(){
  d.loadStatus.innerHTML = '<span class="dot busy"></span> Loading…';
  try{
    const tfile = d.trainFile.files[0];
    if(!tfile) { alert('Please choose train.csv'); return; }
    state.rawTrain = (await parseWithPapa(tfile)).map(normalizeRow);
    if(d.testFile.files[0]) state.rawTest = (await parseWithPapa(d.testFile.files[0])).map(normalizeRow); else state.rawTest=[];

    // simple missingness
    const n=state.rawTrain.length, cols=Object.keys(state.rawTrain[0]||{});
    const missPct = cols.length? mean(cols.map(c=> state.rawTrain.reduce((m,r)=>m+((r[c]==null)?1:0),0)/n )) : 0;

    d.kTrain.textContent=String(n);
    d.kTest.textContent=String(state.rawTest.length);
    d.kMiss.textContent=pct(missPct)+'%';
    d.kRep.textContent='—';

    // show preview with original headers for sanity
    const rawPreview = (await new Promise((resolve)=>{
      Papa.parse(tfile, {header:true, preview:8, complete:r=>resolve(r.data)});
    }));
    renderPreview(rawPreview);

    d.loadStatus.innerHTML = '<span class="dot ok"></span> Loaded';
  }catch(err){
    console.error(err); alert('Load failed: '+err);
    d.loadStatus.innerHTML = '<span class="dot idle"></span> Idle';
  }
}

// ---------- Preprocess ----------
function buildSchema(rows){
  const cols=Object.keys(rows[0]||{});
  const S={ cols, cats:[], nums:[], ratings:[], depDelay:null, arrDelay:null,
    has:k=>cols.includes(k)
  };
  for(const c of cols){
    if(SERVICE_KEYS.has(c)) { S.ratings.push(c); continue; }
    if(DELAY_KEYS.dep.has(c)) S.depDelay=c; else if(DELAY_KEYS.arr.has(c)) S.arrDelay=c; else {
      // simple heuristic: numeric if value looks number-ish
      const v = rows.find(r=>r[c]!=null)?.[c];
      const isNum = typeof v==='number' || /^\d+(\.\d+)?$/.test(String(v||''));
      // label column
      if(c==='satisfaction') continue;
      // id column
      if(['id','passengerid','index'].includes(c)) continue;
      // key categoricals
      if(['gender','customertype','typeoftravel','class'].includes(c)) S.cats.push(c);
      else if(isNum) S.nums.push(c); else S.cats.push(c);
    }
  }
  return S;
}

function imputeAndEncode(trainRows, testRows, opts){
  // opts: {useCase:'pre'|'post', cross:boolean, totalDelay:boolean, dropRatings:boolean, fast:boolean}
  const S = buildSchema(trainRows);
  const dropRatings = !!opts.dropRatings;
  const usePre = opts.useCase==='pre';

  // Choose feature lists
  const cats = [...S.cats];
  const ratings = dropRatings? [] : [...S.ratings];
  const nums = [...S.nums];
  // Manage delays
  const dep = S.depDelay; const arr = usePre? null : S.arrDelay; // exclude arrival delay for pre‑flight
  if(dep && !nums.includes(dep)) nums.push(dep);
  if(arr && !nums.includes(arr)) nums.push(arr);

  // Engineered features
  const engineered = [];
  const haveDep = !!dep, haveArr = !!arr;
  if(opts.totalDelay && haveDep){ engineered.push('totaldelay'); }
  if(opts.cross){ engineered.push('cross_classtype'); }

  // Impute medians for numerics
  const med = {};
  const trainNums = trainRows.map(r=>({ ...r, totaldelay: (haveDep? +r[dep]||0:0) + (haveArr? +r[arr]||0:0) }));
  for(const c of nums){ const arrv = trainRows.map(r=> r[c]!=null? +r[c] : null).filter(v=>v!=null); med[c] = median(arrv) ?? 0; }
  if(opts.totalDelay && haveDep){ const arrv = trainNums.map(r=> +r.totaldelay ); med['totaldelay']=median(arrv)??0; }

  // Mode for categoricals (including ratings – they are ordinal 0..5 but treat as num later)
  const mode = {};
  for(const c of cats){ const counts={}; for(const r of trainRows){ const v=r[c]; if(v==null) continue; counts[v]=(counts[v]||0)+1; } mode[c]=Object.entries(counts).sort((a,b)=>b[1]-a[1])[0]?.[0] ?? null; }
  for(const c of ratings){ const counts={}; for(const r of trainRows){ const v=r[c]; if(v==null) continue; counts[v]=(counts[v]||0)+1; } mode[c]=Object.entries(counts).sort((a,b)=>b[1]-a[1])[0]?.[0] ?? 3; }

  // Vocab for categoricals (fit on train)
  const voc = {}; for(const c of cats){ voc[c] = Array.from(new Set(trainRows.map(r=>r[c]).filter(v=>v!=null))).slice(0,50); }
  if(opts.cross){
    voc['cross_classtype'] = Array.from(new Set(trainRows.map(r=> `${r['class']||'?' }__${r['typeoftravel']||'?'}` )));
  }

  const allNum = [...nums, ...(opts.totalDelay && haveDep? ['totaldelay']:[]) , ...ratings ];

  // Standardize numerics on train
  const mu={}, sigma={};
  for(const c of allNum){ const xs=trainRows.map(r=> (c==='totaldelay'? ((+r[dep]||0)+(+r[arr]||0)) : (+r[c] ?? NaN)) ).filter(v=>!Number.isNaN(v)); const m=mean(xs); const s=Math.sqrt(mean(xs.map(v=>(v-m)*(v-m)))||1e-8) || 1; mu[c]=m; sigma[c]=s; }

  // Row -> feature vectors
  function rowToFeatures(r){
    // numeric part (deep)
    const deep = [];
    for(const c of allNum){
      let v; if(c==='totaldelay'){ v=(+r[dep]||0)+(+r[arr]||0); if(!haveArr) v=(+r[dep]||0); }
      else { v = r[c]; if(v==null) v = med[c]; }
      if(v==null) v = med[c]??0;
      const z = ( ( +v ) - mu[c]) / (sigma[c]||1);
      deep.push( Number.isFinite(z)? z : 0 );
    }
    // categorical one‑hots (wide)
    const wide = [];
    for(const c of cats){ const vocab=voc[c]; const v=r[c]??mode[c]; for(const t of vocab){ wide.push( v===t ? 1:0 ); } }
    if(opts.cross){ const v = `${r['class']||'?' }__${r['typeoftravel']||'?'}`; const vocab=voc['cross_classtype']; for(const t of vocab){ wide.push(v===t?1:0); } }
    return {deep, wide};
  }

  // Assemble X/Y for train, plus a stratified split
  const labeled = trainRows.map(r=> ({ y:+r['satisfaction'], ...rowToFeatures(r) }));
  // shuffle but preserve class balance
  const pos = labeled.filter(x=>x.y===1), neg=labeled.filter(x=>x.y===0);
  const rate = 0.2; // 80/20 split
  const valP = Math.floor(pos.length*rate), valN=Math.floor(neg.length*rate);
  const trainArr = pos.slice(valP).concat(neg.slice(valN));
  const valArr = pos.slice(0,valP).concat(neg.slice(0,valN));

  // Optional FAST subset for speed
  if(state.fast){
    const capTrain = 60000; const capVal = 20000;
    shuffleInPlace(trainArr); shuffleInPlace(valArr);
    trainArr.splice(capTrain);
    valArr.splice(capVal);
  }

  const Xw = tf.tensor2d(trainArr.flatMap(o=>o.wide), [trainArr.length, trainArr[0].wide.length], 'float32');
  const Xd = tf.tensor2d(trainArr.flatMap(o=>o.deep), [trainArr.length, trainArr[0].deep.length], 'float32');
  const Y  = tf.tensor2d(trainArr.map(o=>[o.y]), [trainArr.length,1], 'float32');

  const XwV = tf.tensor2d(valArr.flatMap(o=>o.wide), [valArr.length, valArr[0].wide.length], 'float32');
  const XdV = tf.tensor2d(valArr.flatMap(o=>o.deep), [valArr.length, valArr[0].deep.length], 'float32');
  const YV  = tf.tensor2d(valArr.map(o=>[o.y]), [valArr.length,1], 'float32');

  const test = (state.rawTest.length? state.rawTest : []).map(r=>rowToFeatures(r));
  const XtW = test.length? tf.tensor2d(test.flatMap(o=>o.wide), [test.length, test[0].wide.length], 'float32') : null;
  const XtD = test.length? tf.tensor2d(test.flatMap(o=>o.deep), [test.length, test[0].deep.length], 'float32') : null;

  return {
    info: {
      wideLen: trainArr[0].wide.length, deepLen: trainArr[0].deep.length,
      wideTrain: [trainArr.length, trainArr[0].wide.length], deepTrain: [trainArr.length, trainArr[0].deep.length],
      wideVal: [valArr.length, valArr[0].wide.length], deepVal: [valArr.length, valArr[0].deep.length],
      engineered, ratings: ratings.slice(), dropRatings, usePre, dep, arr
    },
    tensors: { Xw, Xd, Y, XwV, XdV, YV, XtW, XtD },
    helpers: { rowToFeatures }
  };
}

function shuffleInPlace(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } }

// ---------- Model ----------
function buildModel(info){
  const deepIn = tf.input({shape:[info.deepLen], name:'deep'});
  let x = tf.layers.dense({units:32, activation:'relu'}).apply(deepIn);
  x = tf.layers.dropout({rate:0.1}).apply(x);
  x = tf.layers.dense({units:8, activation:'relu'}).apply(x);

  const wideIn = tf.input({shape:[info.wideLen], name:'wide'});
  const wideLogit = tf.layers.dense({units:1, useBias:true}).apply(wideIn);
  const deepLogit = tf.layers.dense({units:1, useBias:true}).apply(x);
  const add = tf.layers.add().apply([wideLogit, deepLogit]);
  const out = tf.layers.activation({activation:'sigmoid', name:'out'}).apply(add);
  const model = tf.model({inputs:[deepIn, wideIn], outputs:out});

  const lr = state.fast? 0.004 : 0.001;
  model.compile({optimizer: tf.train.adam(lr), loss:'binaryCrossentropy', metrics:['accuracy']});
  return model;
}

function modelSummaryText(model){
  let txt=''; model.summary(80, undefined, x=>txt+=x+'\n'); return txt;
}

// ---------- Training & Metrics ----------
function aucRoc(yTrue, yProb){
  // yTrue: Float32Array(0/1), yProb: Float32Array
  const pairs = Array.from(yProb).map((p,i)=>({p,y:+yTrue[i]}));
  pairs.sort((a,b)=> b.p-a.p );
  let tp=0, fp=0; const P=sum(pairs.map(o=>o.y)), N=pairs.length-P;
  const tpr=[0], fpr=[0]; let lastP=Infinity;
  for(const o of pairs){ if(o.p!==lastP){ tpr.push(tp/P); fpr.push(fp/N); lastP=o.p; } if(o.y===1) tp++; else fp++; }
  tpr.push(1); fpr.push(1);
  // trapezoidal AUC
  let auc=0; for(let i=1;i<fpr.length;i++){ const dx=fpr[i]-fpr[i-1]; const y=(tpr[i]+tpr[i-1])/2; auc+=dx*y; }
  return {tpr, fpr, auc};
}

function drawRoc(canvas, roc){
  const ctx = canvas.getContext('2d'); const w=canvas.width, h=canvas.height; ctx.clearRect(0,0,w,h);
  ctx.fillStyle='rgba(255,255,255,0.06)'; ctx.fillRect(0,0,w,h);
  // axes
  ctx.strokeStyle='rgba(200,200,220,.5)'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(40,h-30); ctx.lineTo(w-20,h-30); ctx.lineTo(w-20,20); ctx.stroke();
  // diagonal
  ctx.strokeStyle='rgba(200,200,220,.35)'; ctx.beginPath(); ctx.moveTo(40,h-30); ctx.lineTo(w-20,20); ctx.stroke();
  if(!roc) return;
  ctx.strokeStyle='rgba(138,163,255,1)'; ctx.lineWidth=2; ctx.beginPath();
  for(let i=0;i<roc.fpr.length;i++){
    const x=40 + (w-60)*roc.fpr[i]; const y=h-30 - (h-50)*roc.tpr[i]; if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
  }
  ctx.stroke();
}

function confusionMetrics(yTrue, yProb, thr){
  let tp=0,fp=0,tn=0,fn=0; for(let i=0;i<yProb.length;i++){ const p=yProb[i]; const y=+yTrue[i]; const pred=p>=thr?1:0; if(pred===1&&y===1) tp++; else if(pred===1&&y===0) fp++; else if(pred===0&&y===0) tn++; else fn++; }
  const prec = tp+fp ? tp/(tp+fp):0, rec = tp+fn? tp/(tp+fn):0; const f1 = (prec+rec)? 2*prec*rec/(prec+rec):0;
  return {tp,fp,tn,fn,prec,rec,f1};
}

async function trainOnce(prepped, {epochs, batchSize}){
  state.training=true; d.trainStatus.innerHTML='<span class="dot busy"></span> Training…';
  const {Xw, Xd, Y, XwV, XdV, YV} = prepped.tensors;
  const model = buildModel(prepped.info);
  const es = tf.callbacks.earlyStopping({monitor:'val_loss', patience: state.fast? 2:3, restoreBestWeights:true});
  const history = await model.fit([Xd, Xw], Y, {
    epochs, batchSize, shuffle:true, validationData:[[XdV,XwV], YV], callbacks:[es, {
      onEpochEnd: async (e, logs)=>{ d.log.textContent += `epoch ${e+1}: loss=${logs.loss.toFixed(4)} val_loss=${logs.val_loss.toFixed(4)} acc=${logs.acc?.toFixed(4)}\n`; await sleep(0); }
    }] });

  // validation probs for ROC
  const valProbsT = model.predict([XdV, XwV]);
  const valProbs = (await valProbsT.data()).slice(); valProbsT.dispose();
  const yv = (await YV.data()).slice();
  const roc = aucRoc(yv, valProbs);
  return {model, roc, valProbs, valY: yv};
}

function updateMetricsView(){
  if(!state.roc) return;
  drawRoc(d.roc, state.roc);
  d.aucNow.textContent = state.roc? state.roc.auc.toFixed(4) : '—';
  d.aucPrev.textContent = (state.lastAUC!=null)? state.lastAUC.toFixed(4) : '—';
  const thr = +d.thr.value; const m = confusionMetrics(state.valY, state.valProbs, thr);
  d.tp.textContent=m.tp; d.fp.textContent=m.fp; d.tn.textContent=m.tn; d.fn.textContent=m.fn;
  d.prec.textContent=(pct(m.prec)+'%'); d.rec.textContent=(pct(m.rec)+'%'); d.f1.textContent=m.f1.toFixed(3);
}

// ---------- Events ----------

d.btnLoad.onclick = loadFiles;

d.btnPrep.onclick = async ()=>{
  try{
    if(!state.rawTrain.length) return alert('Load CSVs first');
    state.fast = d.fastMode.checked;
    const opts = { useCase: d.useCase.value, cross:d.featCross.checked, totalDelay:d.featTotalDelay.checked, dropRatings:d.dropRatings.checked };
    d.prepInfo.textContent = 'Running…';
    state.prepped = imputeAndEncode(state.rawTrain, state.rawTest, opts);
    const inf=state.prepped.info; const lines=[
      `Use case: ${opts.useCase==='pre'?'Pre-flight (ArrivalDelay excluded)':'Post-flight (ArrivalDelay included)'}`,
      `Wide len: ${inf.wideLen} | Deep len: ${inf.deepLen}`,
      `Train: wide ${inf.wideTrain.join(',')} / deep ${inf.deepTrain.join(',')} | Val: wide ${inf.wideVal.join(',')} / deep ${inf.deepVal.join(',')}`,
      `Impute: medians for numerics; modes for categoricals`,
      `Engineered: Cross=${d.featCross.checked}, TotalDelay=${d.featTotalDelay.checked}`,
      `Ratings dropped: ${inf.dropRatings}`
    ];
    d.prepInfo.textContent = lines.join('\n');
  }catch(e){ console.error(e); alert('Preprocessing failed: '+e.message); }
};


d.btnBuild.onclick = ()=>{
  if(!state.prepped) return alert('Run preprocessing first');
  if(state.model) { state.model.dispose(); state.model=null; }
  state.model = buildModel(state.prepped.info);
  d.modelSummary.textContent = 'Model built.';
};

d.btnSummary.onclick = ()=>{
  if(!state.model) return alert('Build model first');
  d.modelSummary.textContent = modelSummaryText(state.model);
};

let stopFlag=false; d.btnEarly.onclick = ()=>{ stopFlag=true; };

d.btnTrain.onclick = async ()=>{
  try{
    if(state.training) return alert('A training run is already in progress.');
    if(!state.prepped) return alert('Preprocess first');
    if(!state.model) state.model = buildModel(state.prepped.info);
    d.log.textContent=''; stopFlag=false; state.fast=d.fastMode.checked;
    const epochs = state.fast? 12: 25; const batchSize = state.fast? 128: 64;
    const {model, roc, valProbs, valY} = await trainOnce(state.prepped, {epochs, batchSize});
    if(state.model) state.model.dispose(); state.model=model;
    state.lastAUC = state.roc?.auc ?? null;
    state.roc=roc; state.valProbs=valProbs; state.valY=valY; updateMetricsView();
    d.trainStatus.innerHTML = '<span class="dot ok"></span> Done';
    state.training=false;
  }catch(e){ console.error(e); state.training=false; d.trainStatus.innerHTML='<span class="dot idle"></span> Idle'; alert('Training failed: '+e.message); }
};

d.thr.oninput = ()=> updateMetricsView();

// Quick compare: tiny fast models for pre vs post, show both AUCs side‑by‑side

d.btnCompare.onclick = async ()=>{
  try{
    if(state.training) return alert('Wait for current training to finish.');
    if(!state.rawTrain.length) return alert('Load CSVs first');
    d.aucPre.textContent='…'; d.aucPost.textContent='…';
    const base = { cross:d.featCross.checked, totalDelay:d.featTotalDelay.checked, dropRatings:d.dropRatings.checked };
    state.fast=true; // force fast
    const tiny = {epochs:6, batchSize:128};

    // POST
    const post = imputeAndEncode(state.rawTrain, state.rawTest, {...base, useCase:'post'});
    const rPost = await trainOnce(post, tiny); rPost.model.dispose();
    d.aucPost.textContent = rPost.roc.auc.toFixed(4);

    // PRE (arrival delay excluded + optional ratings dropped)
    const pre = imputeAndEncode(state.rawTrain, state.rawTest, {...base, useCase:'pre'});
    const rPre = await trainOnce(pre, tiny); rPre.model.dispose();
    d.aucPre.textContent = rPre.roc.auc.toFixed(4);

    // restore fast toggle
    state.fast = d.fastMode.checked;
  }catch(e){ console.error(e); alert('Quick compare failed: '+e.message); }
};

// ---------- Predict & Export ----------

d.btnPredict.onclick = async ()=>{
  try{
    if(!state.model || !state.prepped) return alert('Train a model first');
    const {XtD, XtW} = state.prepped.tensors; if(!XtD || !XtW){ d.predInfo.textContent='No test.csv loaded.'; return; }
    const probsT = state.model.predict([XtD, XtW]);
    const probs = Array.from(await probsT.data()); probsT.dispose();
    state.testProbs = probs; d.predInfo.textContent = `Predicted ${probs.length} rows.`;
  }catch(e){ console.error(e); alert('Predict failed: '+e.message); }
};

function requireProbs(){ if(!state.testProbs){ alert('Run Predict first'); return false;} return true; }

d.btnSub.onclick = ()=>{
  if(!requireProbs()) return;
  // Find a passenger id like column in test
  const keys = Object.keys(state.rawTest[0]||{});
  const pid = keys.find(k=> ['id','passengerid','index'].includes(k) ) || keys[0];
  const thr = +d.thr.value; const rows = state.rawTest.map((r,i)=> ({ PassengerId: r[pid], satisfaction: (state.testProbs[i]>=thr?1:0) }));
  downloadCsv('submission.csv', rows);
};

d.btnProb.onclick = ()=>{
  if(!requireProbs()) return;
  const keys = Object.keys(state.rawTest[0]||{}); const pid = keys.find(k=> ['id','passengerid','index'].includes(k) ) || keys[0];
  const rows = state.rawTest.map((r,i)=> ({ PassengerId: r[pid], prob: state.testProbs[i] }));
  downloadCsv('probabilities.csv', rows);
};

d.btnSave.onclick = async ()=>{
  try{
    if(!state.model) return alert('Train a model first');
    await state.model.save('downloads://airline-wide-deep-tfjs');
  }catch(e){ alert('Save failed: '+e.message); }
};

// helpers for status pill
function setTrainStatus(kind){ d.trainStatus.innerHTML = kind==='ok'? '<span class="dot ok"></span> Done' : kind==='busy'? '<span class="dot busy"></span> Working…' : '<span class="dot idle"></span> Idle'; }
