/* =========================================================================
   Airline Passenger Satisfaction — Wide & Deep (TF.js)
   FAST + ROBUST + NO-LEAKAGE + BUTTONS ALWAYS WORK
   - All handlers exposed via window.__app to avoid missing listeners
   - CSV parsing forces Kaggle defaults (comma + double-quote) and uses
     FileReader fallback (for Safari/iOS that lacks File.text()).
   - Preprocessing stats (median/mean/std, categorical vocab) are computed
     ONLY on the TRAIN SPLIT (no leakage into validation/test).
   - "Pre-flight" mode excludes ArrivalDelay from every step (incl. features
     like totaldelay) to avoid post-event leakage.
   - Wide&Deep model: wide (one-hots + optional cross), deep (numeric z-scores),
     Dense(32,relu)->Dropout(0.1)->Dense(8,relu)->sigmoid. ~0.9k params.
   - 25 epochs, batch 64, early stopping (patience 3). ROC/AUC + threshold slider.
   ========================================================================= */

(() => {
  "use strict";

  // ---- state ----
  const S = {
    rawTrain: [], rawTest: [],
    map: null,
    xsWTr: null, xsDTr: null, ysTr: null,
    xsWVa: null, xsDVa: null, ysVa: null,
    model: null,
    valProbs: null, testProbs: null, testIDs: null,
    thresh: 0.5,
    isTraining: false
  };

  // ---- helpers ----
  const $ = (id) => document.getElementById(id);

  function showToast(msg, ms = 3200) {
    const t = $('toast');
    if (!t) return alert(msg);
    t.textContent = msg;
    t.classList.remove('hidden');
    setTimeout(() => t.classList.add('hidden'), ms);
  }

  const BTN_IDS = ['btnLoad','btnPre','btnBuild','btnSummary','btnTrain','btnStop','btnPredict','btnSub','btnProb','btnSaveModel'];

  function setBusy(on) {
    S.isTraining = !!on;
    BTN_IDS.forEach(id => {
      const el = $(id);
      if (!el) return;
      if (id === 'btnStop') {
        el.disabled = !on;
      } else {
        el.disabled = !!on;
      }
    });
    const dot = $('trainDot'), txt = $('trainText');
    if (dot && txt) {
      dot.classList.toggle('busy', !!on);
      txt.textContent = on ? 'Training…' : 'Idle';
    }
  }

  function escapeHtml(s) {
    return String(s ?? '')
      .replace(/&/g,'&amp;')
      .replace(/</g,'&lt;')
      .replace(/>/g,'&gt;');
  }

  function previewTable(rows, limit = 8) {
    const mount = $('previewTable');
    if (!mount) return;
    if (!rows || !rows.length) { mount.innerHTML = ''; return; }
    const cols = Object.keys(rows[0]);
    const thead = '<thead><tr>' + cols.map(c=>`<th>${escapeHtml(c)}</th>`).join('') + '</tr></thead>';
    const bodyRows = rows.slice(0, limit).map(r => {
      return '<tr>' + cols.map(c=>`<td>${escapeHtml(r[c])}</td>`).join('') + '</tr>';
    }).join('');
    mount.innerHTML = `<table>${thead}<tbody>${bodyRows}</tbody></table>`;
  }

  // ---- CSV parsing (Kaggle settings + Safari-safe FileReader) ----
  function fileToText(file) {
    if (!file) return Promise.resolve('');
    if (typeof file.text === 'function') return file.text(); // modern browsers
    return new Promise((resolve, reject) => {
      const fr = new FileReader();
      fr.onload = () => resolve(fr.result);
      fr.onerror = reject;
      fr.readAsText(file);
    });
  }

  async function parseWithPapaFromFile(file) {
    const text = (await fileToText(file)).replace(/^\uFEFF/, '');
    return new Promise((resolve, reject) => {
      Papa.parse(text, {
        header: true,
        dynamicTyping: true,
        skipEmptyLines: 'greedy',
        // Force Kaggle defaults to avoid comma-in-field issues:
        delimiter: ',',
        quoteChar: '"',
        // Be lenient to odd headers (BOM/extra spaces):
        transformHeader: h => String(h || '').replace(/^\uFEFF/, '').trim(),
        complete: (res) => resolve(res.data),
        error: (err) => reject(err)
      });
    });
  }

  // ---- column normalization & aliases ----
  const norm = s => String(s ?? '').toLowerCase().replace(/[^a-z0-9]/g,'');
  const ALIAS = new Map(Object.entries({
    gender:'gender', sex:'gender',
    customertype:'customertype','customer_type':'customertype',
    typeoftravel:'typeoftravel','type_of_travel':'typeoftravel',
    class:'class',
    satisfaction:'satisfaction','satisfied':'satisfaction',
    age:'age',
    flightdistance:'flightdistance','flight_distance':'flightdistance',
    inflightwifiservice:'inflightwifiservice','inflight_wifi_service':'inflightwifiservice','wifi':'inflightwifiservice',
    departurearrivaltimeconvenient:'timeconvenient','departuretimeconvenient':'timeconvenient','arrivaltimeconvenient':'timeconvenient',
    easeofonlinebooking:'easeonline','ease_online_booking':'easeonline',
    gatelocation:'gatelocation','gate_location':'gatelocation',
    foodanddrink:'fooddrink','food_drink':'fooddrink',
    onlineboarding:'onlineboarding','online_boarding':'onlineboarding',
    seatcomfort:'seatcomfort','seat_comfort':'seatcomfort',
    inflightentertainment:'inflightentertainment','inflight_entertainment':'inflightentertainment',
    onboardservice:'onboardservice','on_board_service':'onboardservice',
    legroomservice:'legroomservice','leg_room_service':'legroomservice',
    baggagehandling:'baggagehandling','baggage_handling':'baggagehandling',
    checkinservice:'checkinservice','check_in_service':'checkinservice',
    inflightservice:'inflightservice','inflight_service':'inflightservice',
    cleanliness:'cleanliness',
    departuredelayinminutes:'departuredelay','departuredelay':'departuredelay',
    arrivaldelayinminutes:'arrivaldelay','arrivaldelay':'arrivaldelay',
    id:'id', passengerid:'id'
  }));

  function normalizeRow(row){
    const out = {};
    for (const [k,v] of Object.entries(row)) {
      const key = ALIAS.get(norm(k));
      if (!key) continue;
      if (v === '' || v === undefined) {
        out[key] = null;
      } else {
        out[key] = typeof v === 'string' ? v.trim() : v;
      }
    }
    // normalize label to 0/1
    if ('satisfaction' in out) {
      const val = out.satisfaction;
      out.satisfaction = typeof val === 'string'
        ? (val.toLowerCase().includes('satisfied') && !val.toLowerCase().includes('neutral') ? 1 : 0)
        : Number(val);
    }
    return out;
  }

  function missingPct(rows){
    if (!rows || !rows.length) return 100;
    const keys = Object.keys(rows[0] ?? {});
    let miss = 0;
    const total = rows.length * keys.length;
    for (const r of rows) for (const k of keys) if (r[k] == null || r[k] === '') miss++;
    return total ? +(100 * miss / total).toFixed(1) : 100;
  }

  // ---- stats helpers ----
  const mean = a => {
    const b = a.filter(v => Number.isFinite(v));
    if (!b.length) return 0;
    return b.reduce((s,x)=>s+x,0) / b.length;
  };
  const sd = a => {
    const b = a.filter(v => Number.isFinite(v));
    if (b.length < 2) return 1;
    const m = mean(b);
    return Math.sqrt(b.reduce((s,x)=>s + (x-m)*(x-m), 0)/(b.length-1)) || 1;
  };
  const median = a => {
    const b = a.filter(v => v!=null && Number.isFinite(+v)).map(Number).sort((x,y)=>x-y);
    if (!b.length) return 0;
    const m = Math.floor(b.length/2);
    return b.length % 2 ? b[m] : (b[m-1] + b[m]) / 2;
  };
  const finite = (x, d=0) => Number.isFinite(+x) ? +x : d;

  /* ----------------- build mapping (TRAIN-ONLY stats; no leakage) ----------------- */
  function buildMapping(trainRows){
    const useCase = $('useCase').value;         // 'pre' | 'post'
    const useCross = $('featCross').checked;
    const useTot   = $('featDelay').checked;

    const T = trainRows.map(unifyRow);

    const CAT_KEYS = ['gender','customertype','typeoftravel','class'];
    const NUM_BASE = [
      'age','flightdistance','timeconvenient','easeonline','gatelocation','fooddrink','onlineboarding',
      'seatcomfort','inflightentertainment','onboardservice','legroomservice','baggagehandling',
      'checkinservice','inflightservice','cleanliness','departuredelay'
    ];
    const NUM_KEYS = useCase === 'post' ? [...NUM_BASE, 'arrivaldelay'] : [...NUM_BASE];

    const med={}, mu={}, sig={};
    for (const k of NUM_KEYS) {
      const arr = T.map(r => r[k]==null ? null : +r[k]).filter(v => v!=null && Number.isFinite(v));
      const m = median(arr);
      med[k] = Number.isFinite(m) ? m : 0;
      const vals = T.map(r => finite(r[k], med[k]));
      mu[k]  = mean(vals);
      sig[k] = sd(vals);
    }

    const catVals={};
    for (const k of CAT_KEYS){
      const m = mode(T.map(r => r[k]==null ? null : String(r[k])));
      const uniq = Array.from(new Set(T.map(r => r[k]==null ? m : String(r[k]))));
      if (!uniq.includes('UNK')) uniq.push('UNK');
      catVals[k] = uniq;
    }

    // Cross feature vocab (train-only)
    let crossVals = [];
    const crossKey = 'classXtypeoftravel';
    if (useCross) {
      crossVals = Array.from(new Set(T.map(r => `${String(r.class ?? 'UNK')}|${String(r.typeoftravel ?? 'UNK')}`)));
      if (!crossVals.includes('UNK|UNK')) crossVals.push('UNK|UNK');
    }

    // deep numeric set: don't duplicate cats in deep path; optionally add totaldelay
    const DEEP_NUM = [...NUM_KEYS];
    if (useTot) {
      // Only compute totaldelay from TRAIN-ONLY medians; if useCase==='pre', do NOT add arrival delay part.
      DEEP_NUM.push('totaldelay');
      med.totaldelay = (median(T.map(r => finite(r.departuredelay, med.departuredelay))) || 0) +
                       (useCase === 'post' ? (median(T.map(r => finite(r.arrivaldelay, 0))) || 0) : 0);
      mu.totaldelay = mean(T.map(r => {
        const dep = finite(r.departuredelay, med.departuredelay);
        const arr = (useCase === 'post') ? finite(r.arrivaldelay, 0) : 0;
        return dep + arr;
      }));
      sig.totaldelay = sd(T.map(r => {
        const dep = finite(r.departuredelay, med.departuredelay);
        const arr = (useCase === 'post') ? finite(r.arrivaldelay, 0) : 0;
        return dep + arr;
      })) || 1;
    }

    const idKey = 'id';
    return { useCase, useCross, useTot, med, mu, sig, catVals, WIDE_SPEC:{cats:CAT_KEYS, cross:{enabled:useCross, key:crossKey, values:crossVals}}, DEEP_SPEC:{nums:DEEP_NUM}, idKey };
  }

  function mode(arr){
    const map = new Map(); let best=null, c=0;
    for (const v of arr) {
      if (v==null) continue;
      const k = String(v);
      const n = (map.get(k)||0)+1;
      map.set(k,n);
      if (n>c){ c=n; best=k; }
    }
    return best ?? 'UNK';
  }

  function imputeAndVectorize(rows, M){
    const Xw=[], Xd=[], Y=[], IDS=[];
    for (let i=0;i<rows.length;i++){
      const r0 = unifyRow(rows[i]);
      const rc = {...r0};

      // impute categoricals to mode from TRAIN vocab; unseen -> 'UNK'
      for (const k of M.WIDE_SPEC.cats){
        const vocab = M.catVals[k] || ['UNK'];
        let v = rc[k]==null ? vocab[0] : String(rc[k]);
        if (!vocab.includes(v)) v = 'UNK';
        rc[k] = v;
      }

      // impute + standardize numerics using TRAIN-only med/mu/sig
      for (const k of M.DEEP_SPEC.nums){
        if (k === 'totaldelay') continue; // build below if enabled
        const val = finite(rc[k], null);
        const imputed = val==null ? (M.med[k] ?? 0) : val;
        const z = (imputed - (M.mu[k] ?? 0)) / (M.sig[k] || 1);
        Xd.push([]); // temp push, will fill later
      }

      // Build deep vector properly (not using temp push)
      const deep = [];
      for (const k of M.DEEP_SPEC.nums){
        if (k === 'totaldelay') {
          const dep = finite(rc['departuredelay'], M.med['departuredelay'] ?? 0);
          const arr = (M.useCase === 'post') ? finite(rc['arrivaldelay'], 0) : 0; // no leakage in pre mode
          const td = dep + arr;
          const z = (td - (M.mu.totaldelay ?? 0)) / (M.sig.totaldelay || 1);
          deep.push(Number.isFinite(z) ? z : 0);
        } else {
          const val = finite(rc[k], M.med[k] ?? 0);
          const z = (val - (M.mu[k] ?? 0)) / (M.sig[k] || 1);
          deep.push(Number.isFinite(z) ? z : 0);
        }
      }

      // wide one-hots
      const wide = [];
      for (const k of M.WIDE_SPEC.cats){
        const vocab = M.catVals[k] || ['UNK'];
        const v = rc[k];
        for (const cat of vocab) wide.push(v === cat ? 1 : 0);
      }
      if (M.WIDE_SPEC.cross?.enabled) {
        const key = `${rc['class']||'UNK'}|${rc['typeoftravel']||'UNK'}`;
        for (const cat of M.WIDE_SPEC.cross.values) wide.push(cat === key ? 1 : 0);
      }

      XdeepPush(deep);
      XwidePush(wide);
      IDS.push(('id' in r0) ? r0['id'] : (i+1));
      if ('satisfaction' in rc) Y.push(+rc.satisfaction);
    }

    function XdeepPush(vec){ Xd.push ? Xd[Xw.length] = vec : null; }
    function XwidePush(vec){ Xw.push(vec); }

    // Rebuild properly because of the helper push order
    // (We created deep first for z-scoring; now ensure arrays are aligned.)
    if (Xw.length !== Xd.length) {
      // reconstruct by recomputing both in a single pass
      const _Xw=[], _Xd=[];
      for (let i=0;i<rows.length;i++){
        const r0 = unifyRow(rows[i]);
        const rc = {...r0};
        for(const k of M.WIDE_SPEC.cats){
          const vocab = M.catVals[k] || ['UNK'];
          let v = rc[k]==null ? vocab[0] : String(rc[k]);
          if (!vocab.includes(v)) v = 'UNK';
          rc[k] = v;
        }
        if (M.useTot){
          const dep = finite(rc['departuredelay'], M.med['departuredelay'] ?? 0);
          const arr = (M.useCase === 'post') ? finite(rc['arrivaldelay'], 0) : 0;
          rc['totaldelay'] = dep + arr;
        }
        const deep = [];
        for (const k of M.DEEP_SPEC.nums){
          const val = k==='totaldelay'
            ? rc['totaldelay']
            : finite(rc[k], M.med[k] ?? 0);
          const z = (val - (M.mu[k] ?? 0)) / (M.sig[k] || 1);
          deep.push(Number.isFinite(z) ? z : 0);
        }
        const wide=[];
        for(const k of M.WIDE_SPEC.cats){
          const vocab=M.catVals[k] || ['UNK'];
          const v=rc[k];
          for (const cat of vocab) wide.push(v===cat?1:0);
        }
        if(M.WIDE_SPEC.cross?.enabled){
          const key = `${rc['class']||'UNK'}|${rc['typeoftravel']||'UNK'}`;
          for (const cat of M.WIDE_SPEC.cross.values) wide.push(cat===key?1:0);
        }
        _Xd.push(deep); _Xw.push(wide);
      }
      Xd.length = 0; Xw.length = 0;
      Array.prototype.push.apply(Xd, _Xd);
      Array.prototype.push.apply(Xw, _Xw);
    }

    return { Xwide: Xw, Xdeep: Xd, y: (Y.length? Y : null), ids: IDS };
  }

  // ---- split stratified (uses label from unified row) ----
  function stratifiedSplitRows(rows, rate = 0.2) {
    const unified = rows.map(r => {
      const u = unifyRow(r);
      return {...r, __y: +u.satisfaction};
    });
    const zeros = unified.filter(r => r.__y === 0);
    const ones  = unified.filter(r => r.__y === 1);

    const shuffle = arr => { const a=arr.slice(); tf.util.shuffle(a); return a; };
    const z = shuffle(zeros), o = shuffle(ones);
    const nZ = Math.max(1, Math.floor(z.length * rate));
    const nO = Math.max(1, Math.floor(o.length * rate));

    const val = z.slice(0, nZ).concat(o.slice(0, nO));
    const train = z.slice(nZ).concat(o.slice(nO));
    tf.util.shuffle(train); tf.util.shuffle(val);
    train.forEach(r => delete r.__y);
    val.forEach(r => delete r.__y);
    return {train, val};
  }

  // ---- model ----
  function buildWideDeep(wideLen, deepLen) {
    const wideIn = tf.input({shape:[wideLen], name:'wide'});
    const deepIn = tf.input({shape:[deepLen], name:'deep'});

    const wideLogit = tf.layers.dense({units:1, useBias:false, activation:'linear', name:'wide_logit'}).apply(wideIn);

    let x = tf.layers.dense({units:32, activation:'relu'}).apply(deepIn);
    x = tf.layers.dropout({rate:0.1}).apply(x);
    x = tf.layers.dense({units:8, activation:'relu'}).apply(x);
    const deepLogit = tf.layers.dense({units:1, activation:'linear', name:'deep_logit'}).apply(x);

    const sum = tf.layers.add().apply([wideLogit, deepLogit]);
    const out = tf.layers.activation({activation:'sigmoid', name:'out'}).apply(sum);

    const model = tf.model({inputs:[wideIn, deepIn], outputs:out, name:'wide_deep'});
    model.compile({optimizer:'adam', loss:'binaryCrossentropy', metrics:['accuracy']});
    return model;
  }

  function modelSummaryText(m) {
    const lines = [];
    lines.push('==============================================================');
    lines.push(`${m.name} — ${m.layers.length} layers`);
    lines.push('--------------------------------------------------------------');
    for (const layer of m.layers) {
      const inShape  = Array.isArray(layer.inputShape) ? JSON.stringify(layer.inputShape) : String(layer.inputShape);
      const outShape = Array.isArray(layer.outputShape)? JSON.stringify(layer.outputShape): String(layer.outputShape);
      const params   = typeof layer.countParams === 'function' ? layer.countParams() : (layer.trainableWeights||[]).reduce((s,w)=>s+(w.shape?.reduce((a,b)=>a*b,1)||0),0);
      lines.push(`${layer.name} (${layer.getClassName()}): in ${inShape} -> out ${outShape} | params ${params}`);
    }
    lines.push('--------------------------------------------------------------');
    lines.push(`Total params: ${m.countParams()}`);
    lines.push('==============================================================');
    return lines.join('\n');
  }

  // ---- metrics ----
  function rocPoints(yTrue, yProb, steps=200){
    const T=[]; for(let i=0;i<=steps;i++) T.push(i/steps);
    const pts=T.map(th=>{
      let TP=0,FP=0,TN=0,FN=0;
      for(let i=0;i<yTrue.length;i++){
        const y = yTrue[i] > 0.5 ? 1 : 0;
        const p = yProb[i] >= th ? 1 : 0;
        if (y===1 && p===1) TP++;
        else if (y===0 && p===1) FP++;
        else if (y===0 && p===0) TN++;
        else FN++;
      }
      const TPR = TP / (TP + FN || 1);
      const FPR = FP / (FP + TN || 1);
      return {x: FPR, y: TPR, th};
    });
    const s=pts.slice().sort((a,b)=>a.x-b.x);
    let auc=0;
    for (let i=1;i<s.length;i++){
      const a=s[i-1], b=s[i];
      auc += (b.x - a.x) * (a.y + b.y) / 2;
    }
    return {points:s, auc};
  }

  function drawROC(canvas, pts){
    if (!canvas) return;
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    ctx.clearRect(0,0,W,H);
    // grid
    ctx.fillStyle = '#0f1628';
    ctx.fillRect(0,0,W,H);
    ctx.strokeStyle = '#233350';
    ctx.lineWidth = 1;
    for(let i=0;i<=5;i++){
      const x=i/5;
      ctx.beginPath(); ctx.moveTo(40+x*(W-60), H-30); ctx.lineTo(40+x*(W-60), 20); ctx.stroke();
    }
    for(let i=0;i<=5;i++){
      const y=i/5;
      ctx.beginPath(); ctx.moveTo(40, 20+y*(H-50)); ctx.lineTo(W-20, 20+y*(H-50)); ctx.stroke();
    }
    // curve
    ctx.strokeStyle = '#8aa3ff';
    ctx.lineWidth = 2;
    ctx.beginPath();
    pts.forEach((p,i)=>{ const x=40+p.x*(W-60), y=H-30-p.y*(H-50); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); });
    ctx.stroke();
  }

  function confusionStats(yTrue, yProb, th){
    let TP=0,FP=0,TN=0,FN=0;
    for(let i=0;i<yTrue.length;i++){
      const y = yTrue[i] > 0.5 ? 1 : 0;
      const p = yProb[i] >= th ? 1 : 0;
      if (y===1&&p===1) TP++; else if (y===0&&p===1) FP++; else if (y===0&&p===0) TN++; else FN++;
    }
    const prec=TP/(TP+FP||1), rec=TP/(TP+FN||1), f1=(2*prec*rec)/((prec+rec)||1);
    return {TP,FP,TN,FN,prec,rec,f1};
  }

  // ---- train guards ----
  function ensureReadyForTraining(){
    if(!(S.xsWTr && S.xsDTr && S.ysTr && S.xsWVa && S.xsDVa && S.ysVa)){
      throw new Error('Tensors not built. Click “Run Preprocessing” first.');
    }
    const nTr=S.xsWTr.shape[0];
    if(nTr===0) throw new Error('No training rows after preprocessing.');
    if(S.xsWTr.shape[0]!==S.xsDTr.shape[0] || S.xsWTr.shape[0]!==S.ysTr.shape[0]){
      throw new Error(`Train shape mismatch: wide=${S.xsWTr.shape} deep=${S.xsDTr.shape} y=${S.ysTr.shape}`);
    }
    if(S.xsWVa.shape[0]!==S.xsDVa.shape[0] || S.xsWVa.shape[0]!==S.ysVa.shape[0]){
      throw new Error(`Val shape mismatch: wide=${S.xsWVa.shape} deep=${S.xsDVa.shape} y=${S.ysVa.shape}`);
    }
    if(S.xsWTr.shape[1]===0 || S.xsDTr.shape[1]===0){
      throw new Error('Feature vectors are empty (0 columns). Check categorical mapping.');
    }
  }

  // ---- model I/O ----
  function buildModel() {
    if (!S.xsWTr || !S.xsDTr) { showToast('Run Preprocessing first'); return; }
    S.model?.dispose?.();
    S.model = buildWideDeep(S.xsWTr.shape[1], S.xsDTr.shape[1]);
    $('modelSummary').textContent = 'Model built. Click “Show Summary”.';
  }

  function showSummary(){
    if(!S.model){ showToast('Build the model first'); return; }
    $('modelSummary').textContent = summarizeModel(S.model);
  }

  // ---- CSV → state ----
  async function loadFiles(){
    try{
      const fT = $('trainFile')?.files?.[0];
      const fX = $('testFile')?.files?.[0];

      if (!fT) {
        showToast('Please choose train.csv first.'); 
        return;
      }

      const trainRows = (await parseWithPapaFromFile(fT)).map(normalizeRow);
      const testRows  = fX ? (await parseWithPapaFromFile(fX)).map(normalizeRow) : [];

      S.rawTrain = trainRows;
      S.rawTest  = testRows;

      $('kTrain').textContent = String(trainRows.length);
      $('kTest').textContent  = testRows.length ? String(testRows.length) : '—';
      $('kMiss').textContent  = missingPct(trainRows) + '%';
      $('fixNote').textContent= 'CSV parsed with comma + double-quote (Kaggle default).';

      previewTable(trainRows);
      showToast('Files loaded. Now click “Run Preprocessing”.');
    }catch(err){
      console.error(err);
      showToast('Load failed: ' + (err?.message || err));
    }
  }

  function imputeAndTensorize(trainRows, valRows, M){
    const TV = imputeAndVectorize(trainRows, M);
    const VV = imputeAndVectorize(valRows,   M);

    // dispose old tensors if any
    [S.xsWTr,S.xsDTr,S.ysTr,S.xsWVa,S.xsDVa,S.ysVa].forEach(t=>t?.dispose?.());

    S.xsWTr = tf.tensor2d(TV.Xwide, [TV.Xwide.length, TV.Xwide[0].length], 'float32');
    S.xsDTr = tf.tensor2d(TV.Xdeep, [TV.Xdeep.length, TV.Xdeep[0].length], 'float32');
    S.ysTr  = tf.tensor2d(TV.y, [TV.y.length, 1], 'float32');

    S.xsWVa = tf.tensor2d(VV.Xwide, [VV.Xwide.length, VV.Xwide[0].length], 'float32');
    S.xsDVa = tf.tensor2d(VV.Xdeep, [VV.Xdeep.length, VV.Xdeep[0].length], 'float32');
    S.ysVa  = tf.tensor2d(VV.y, [VV.y.length, 1], 'float32');
  }

  function onPreprocess(){
